	<LO stageColour="0xCCCC99" templateData="_level0.templateData" name="Learning Object">		<SCR isFunc="1" name="roundToNSF"><![CDATA[// Round to n significant figures ...//function roundToNSF(aNumber:Number, digits:Number){// Uses the identity log10(x) = Math.log(x) * Math.LOG10E;aNumber = args[0];digits = args[1];// Round a number to n significant figures:if (aNumber !=0){  if (aNumber > 0){    z = Math.log(aNumber) * Math.LOG10E;  } else {    z = Math.log(-aNumber) * Math.LOG10E;  };  z = Math.floor(z);  nDP = digits - z - 1; // Rounding to nDP decimal places is equivalent to rounding to digits significant figures ...  roundToNDP(aNumber, nDP);} else {  roundedNumStr = aNumber; // Number is zero ...};]]></SCR>		<SCR isFunc="1" name="roundToNDP"><![CDATA[//function roundToNDP(num:Number, digits:Number):String {theNumber = args[0];digits = args[1];	// Round a number to n decimal places:	isNegative = false;	// If no decimal places needed, just use built-in Math.round	if(digits == 0) { roundedNumStr = String(Math.round(theNumber)); };	// Temporarily make number positive, for efficiency	if (theNumber < 0) { isNegative = true; theNumber *= -1; };	// Round the number to specified decimal places e.g. 12.3456 to 3 digits (12.346) => multiply by 1000, round, divide by 1000tenToPower = Math.pow(10, digits);cropped = String(Math.round(theNumber * tenToPower));	// Prepend zeros as appropriate for numbers between 0 and 1	// Example: Round 0.0021 to 3 decimal points. Cropped will now be 2, need to add the extra zeroes.	if(theNumber < 1) {  while(cropped.length < Number(digits) + 1) {    cropped = "0" + cropped;  };};	// Restore negative sign if necessary	if (isNegative) { cropped = "-" + cropped; }; 	if (digits > 0) {		// Insert decimal point in appropriate place (this has the same effect as dividing by		// tenToPower, but preserves trailing zeros) ...		roundedNumStr = cropped.slice(0, -digits) + "." + cropped.slice(-digits);	} else {		// Add back the required number of zeroes ...		roundedNumStr = String(Number(cropped) * Math.pow(10, Math.abs(digits)));	};]]></SCR>		<SCR isFunc="1" name="lookup"><![CDATA[// Look-up function: ////args[0] : The value we are searching for;//args[1] : The list in which we are searching;//args[2] : A list that matches the above list;//args[3] : The value in the second list that corresponds to the value in the first list.// Loop over the first list ...for (iLookUp = 0; iLookUp < args[1].length; iLookUp++){  if (args[1][iLookUp] == args[0]){    // Current element matches the value sought: save it to arg[3] and leave ...    args[3] = args[2][iLookUp];    theReturnedVariable = args[3];    break;  };};]]></SCR>		<SCR isFunc="1" name="createVarsMakeSteps"><![CDATA[theReturn = String.fromCharCode(10);// Create all the variables the piece needs ...// Type: RANGE - choose one value in units of STEP ...for (i = 0; i < templateData.problem[0].variables[0].rangeVar.length; i++){  name = templateData.problem[0].variables[0].rangeVar[i].name;  min = Number(templateData.problem[0].variables[0].rangeVar[i].min);  max = Number(templateData.problem[0].variables[0].rangeVar[i].max);  step = Number(templateData.problem[0].variables[0].rangeVar[i].step);  // Adjust for steps  (<> 1) ...   min = min / step; max = max / step;  // Choose a value for NAME within the specified range ...  engine[name] = (Math.floor(Math.random() * (max - min + 1)) + min) * step;};//Testing variables ...//w = 20; i2 = 1000; k3 = 4800; t = 2;// Type: LIST - choose one element ...for (i = 0; i < templateData.problem[0].variables[0].listVar.length; i++) {  name = templateData.problem[0].variables[0].listVar[i].name;  // Split into an array ...  tempArr = templateData.problem[0].variables[0].listVar[i].list.split(',');  // ... and choose one value randomly ...  tempVal = tempArr[Math.floor(Math.random() * tempArr.length)];  engine[name] = tempVal;};// Type: ARRAY (put an array into a Xerte variable) ...for (i = 0; i < templateData.problem[0].variables[0].arrayVar.length; i++){  name = templateData.problem[0].variables[0].arrayVar[i].name;  // Split into an array ...  engine[name] = templateData.problem[0].variables[0].arrayVar[i].list.split(',');};//Type: EXPRESSION (could use the previous two types) ...debug(templateData.problem[0].variables[0].exprVar.length); for (i = 0; i < templateData.problem[0].variables[0].exprVar.length; i++){  name = templateData.problem[0].variables[0].exprVar[i].name;  roundingDP = templateData.problem[0].variables[0].exprVar[i].roundingDP;  roundingSF = templateData.problem[0].variables[0].exprVar[i].roundingSF;  // The mechanism below means we cannot mix ActionScript functions (e.g. +, -, x, /, Math.sin) and  // local functions (e.g. lookup) ...  evaluateExpression = expression(templateData.problem[0].variables[0].exprVar[i].expr, engine);  if (evaluateExpression == undefined) {    engine[name] = theReturnedVariable;  } else {    engine[name] = evaluateExpression;  };  // Round  to dp decimal places if necessary ...  if (roundingDP != undefined) {debug("DP: " + roundingDP + '; engine[name] is ' + engine[name]);    roundToNDP(engine[name], roundingDP);    engine[name] = roundedNumStr;debug("DP: " + roundingDP + '; engine[name] is ' + engine[name]);  };  if (roundingSF != undefined) {debug("SF: " + roundingSF + '; engine[name] is ' + engine[name]);    roundToNSF(engine[name], roundingSF);    engine[name] = roundedNumStr;debug("SF: " + roundingSF + '; engine[name] is ' + engine[name]);  };};debug ('QQQ is ' + QQQ); //debug ('zz is ' + zz); // Ideally, we would like to do this: lookup('thomas',team,ages,q);//lookup('thomas',team,ages,theReturnedVariable);//lookup('thomas',team,ages);//q = theReturnedVariable; //debug('Hard-wired evaluation (q) ' + q);// Make the steps for this problemx = icon.nextSibling.firstChild;//x.nextSibling.duplicate(templateData.problem[0].step.length - 1);//debug(x);//debug("spilt........................");//debug(x.nextSibling);//icon.nextSibling.firstChild.nextSibling.duplicate(templateData.problem[0].step.length - 1);summaryLine = new Array ();]]></SCR>		<IFC name="Interface" title="My Learning Object" visuals="0">			<FW_ENT name="interface">				<DIS h="560" w="760" name="panel" x="20" y="20" type="ext" url="templatePath  + 'flex/whitePanel.swf'"><![CDATA[]]></DIS>				<SCR name="[Untitled]"><![CDATA[debug('ENTRY: needNewVariables is ' + needNewVariables);needNewVariables = true;]]></SCR>			</FW_ENT>			<PG name="Opening Screen">				<SCR name="Read Opening Comment from XML"><![CDATA[// Is there an opening screen?if (templateData.problem[0].firstScreen.length == undefined){  // Default when opening screen present ...  firstComment = 'Calculations';} else {  firstComment = templateData.problem[0].firstScreen[0];  firstComment = expression(firstComment, engine);};]]></SCR>				<DIS name="feedback" x="40" y="40" w="400" h="10" type="text"><![CDATA[{firstComment}]]></DIS>				<INT name="Interaction" perpetual="0">					<RES id="moveOn" swf="templatePath + 'flex/button.swf'" enabled="1" rs="btnNext" name="moveOn" type="button" x="680" y="540" label="Continue" erase="1" exit="0">						<SCR name="nextPage"><![CDATA[rootIcon.nextPage();]]></SCR>					</RES>				</INT>			</PG>			<SCR name="Duplicate the protoStep"><![CDATA[// This was the original://icon.nextSibling.firstChild.nextSibling.duplicate(templateData.problem[0].step.length - 1);icon.nextSibling.duplicate(templateData.problem[0].step.length - 1);]]></SCR>			<PG name="protoStep" title="Page Title" help="Page Help">				<SCR name="setup"><![CDATA[// Useful variable ...curPage = rootIcon.getPageIndex() - 3; // Need to allow for icons before the protoStep // This is where we should set up the variables ...if (needNewVariables) {debug ('New variables are being set ...');  createVarsMakeSteps();  needNewVariables = false;};stepLayout = templateData.problem[0].step[curPage].layout - 1;// ... path of a decision icon is zero-basedforceBack = templateData.problem[0].step[curPage].forceBack;nHints = templateData.problem[0].step[curPage].hint.length;// Build up the summary array ...//summaryLine[curPage] = (curPage + 1) + ' ';// (Subtract 2 because we want the first icon to be 0 and it is currently 2 - there are// (currently) two icons (lookup and createVarsMakeSteps) ahead of it)attempts = 0;attemptsShowHint = 2; // ... after this number of attempts, show the hintmaxAttempts = templateData.problem[0].step[curPage].attempts;// Work out all correct answers, as there may be more than one - i.e. quadratics etcanswers = new Array();possibleAnswers = new Array();// Loop over the expressions ...for (i = 0; i < templateData.problem[0].step[curPage].expression.length; i++){  obj = new Object();  obj.answer = expression(templateData.problem[0].step[curPage].expression[i], engine);//  obj.answer = Math.round(obj.answer * 100) / 100;  obj.correct = templateData.problem[0].step[curPage].expression[i].correct;  obj.units = templateData.problem[0].step[curPage].expression[i].units;  if (templateData.problem[0].step[curPage].expression[i].proximity != undefined) {    obj.within = templateData.problem[0].step[curPage].expression[i].proximity;  };  obj.feedback = templateData.problem[0].step[curPage].expression[i].feedback;  obj.result = templateData.problem[0].step[curPage].prompt[0].result;  answers.push(obj);  // If a correct answer, add to the summary ...//  if (obj.correct == 'true'){//    summaryLine[curPage] = summaryLine[curPage] + expression(templateData.problem[0].step[curPage].expression[i].internalOnly, engine) + theReturn;//  };  if (obj.correct == "true"){    possibleAnswers.push(obj);  };};//summaryLine[curPage] = summaryLine[curPage] + theReturn;]]></SCR>				<DIS id="problem" name="problem" x="40" y="40" w="350" h="10" type="text"><![CDATA[{expression(templateData.problem[0].step[curPage].prompt, engine)}]]></DIS>				<DIS id="promptImage" name="optionalImage" x="problem._x" y="problem._y + problem._height + 20" type="ext" url="{templateData.problem[0].step[curPage].prompt[0].image}"><![CDATA[]]></DIS>				<DIS id="progressBar" name="Progress Bar" x="0" y="0" type="ext" url="FileLocation + "><![CDATA[]]></DIS>				<SCR name="Layout Parameters"><![CDATA[// Set layout parameters according to which layout has been selected in the template ...if (stepLayout == 0){  // Problem and promptImage are icons already defined ...  with (problem) {_x = 40, _y = 40, _width = 700};  with (promptImage) {_x = problem._x, _y = problem._y + problem._height + 20}; // ... image for problem  userAnswerLayout = { x: problem._x, y: 540, width: 260, height: 100 };  submitLayout = { x: 310, y: 540 };//  fbLayout = { x: 10, y: 70, width: 350}; // ... comment//  hintImg = { x: fbLayout.x, y: fbLayout.y + fb._height + 120 }; // ... hint image  btnNextLayout = { x: 680, y: 540 }; // ... Next step  btnSummaryLayout = { x: 410, y: 540 }; // ... Summary button  progressBarX = 510; progressBarY = 540; progressBarWidth = 150; progressBarHeight = 20; };if (stepLayout == 1){  // Problem and promptImage are icons already defined ...  with (problem) {_x = 40, _y = 40, _width = 350};  with (promptImage) {_x = problem._x, _y = problem._y + problem._height + 20}; // ... image for problem  userAnswerLayout = { x: 410, y: problem._y, width: 260, height: 100 };  submitLayout = { x: 680, y: 40 };  fbLayout = { x: 410, y: 70, width: 350}; // ... comment  hintImg = { x: fbLayout.x, y: fbLayout.y + fb._height + 20 }; // ... hint image  btnNextLayout = { x: 680, y: 540 }; // ... Next step  btnSummaryLayout = { x: 680, y: 510 }; // ... Summary button  progressBarX = 480; progressBarY = 540; progressBarWidth = 150; progressBarHeight = 20; }; ]]></SCR>				<SCR name="Draw Progress Bar"><![CDATA[nSteps = templateData.problem[0].step.length;//progressBarX = 480; progressBarY = 540; //progressBarWidth = 150; progressBarHeight = 20; blockWidth = progressBarWidth / nSteps;//curPage = rootIcon.getPageIndex() - 2; // Need to allow for earlier pages that are not stepswith (progressBar){  lineStyle(0, 0xaaaaaa);  // Draw the frame ...  drawRect(progressBarX, progressBarY, progressBarWidth, progressBarHeight, 0);  // Draw the blocks ...  beginFill(0xffaaaa);  for (iBlock = 0; iBlock < curPage + 1; iBlock++){    drawRect(progressBarX + iBlock * blockWidth, progressBarY, blockWidth, progressBarHeight, 0);      };  endFill();};]]></SCR>				<INT name="basicInteraction" perpetual="1">					<RES id="userAnswer" rs="entryText" name="entryText" type="textEntry" x="userAnswerLayout.x" y="userAnswerLayout.y" w="userAnswerLayout.width" h="userAnswerLayout.height" phrase="match this" scrolling="0" border="1" erase="1" exit="0" />					<RES id="submit" swf="templatePath + 'flex/button.swf'" rs="btnJudge" name="judge" type="button" x="submitLayout.x" y="submitLayout.y" label="Submit" erase="1" exit="0">						<SCR name="judge"><![CDATA[finallyWrong = false;attempts++;attemptsLeft = maxAttempts - attempts;//  attemptsShowHint = templateData.problem[0].step[curPage].attemptsToHint;// templateData.problem[0].step[curPage].hint[0].url// Build up the summary array ...summaryLine[curPage] = (curPage + 1) + ' ';// First loop through all possible answers associating the variable with the value ...for (i = 0; i < possibleAnswers.length; i++){  engine[possibleAnswers[i].result] = possibleAnswers[i].answer;};// ... it may be that more than one value is associated with one variable (and one only). Will deal with// this by overwriting later ...// If a correct answer, build up summary ...//if (obj.correct == 'true'){//  thisSummaryLine = expression(templateData.problem[0].step[curPage].expression[i].internalOnly, engine);//  summaryLine[curPage] = summaryLine[curPage] + thisSummaryLine + theReturn;//debug('The summary text for ' + (curPage + 1) + ' is ' + thisSummaryLine); //};for (i = 0; i < answers.length; i++){  // Decide whether or not this is a known answer ...  // An exact answer or within a range?  // No range specified or answer is zero ...  if (answers[i].answer == 0 || answers[i].within == undefined || answers[i].within == "" || isNaN(entryText.text)){    // EXACT ...    answerIsKnown = Number(answers[i].answer) == Number(entryText.text);  } else {    // RANGE ...    // Only work with a range if a percentage (for the range) has been set and the number is not zero ...    pcError = 100 * ((answers[i].answer - entryText.text) / answers[i].answer);    answerIsKnown = Math.abs(pcError) <= answers[i].within;  };  // Now test where in the logic the present combination lies ...  if (answerIsKnown && answers[i].correct == "true"){    // User has correct answer - note this and move to next step    comment = expression(templateData.problem[0].step[curPage].expression[i].feedback, engine);    // Since correct, not allowed to press Submit again but can press Next provided there are further pages ...    btnJudge.setEnabled(false);    if (rootIcon.currentPage < rootIcon.pageCount - 1){      btnNext.setEnabled(true);    };    thisSummaryLine = expression(templateData.problem[0].step[curPage].expression[i].internalOnly, engine);//    summaryLine[curPage] = summaryLine[curPage] + thisSummaryLine + theReturn;    break;  };  if (attempts == maxAttempts){    // User has run out of steps and answer is wrong    // Had answer been correct, above would have been satisfied and break would have taken effect    comment = expression(templateData.problem[0].step[curPage].finalComment, engine);     hint = templateData.problem[0].step[curPage].expression[i].url;    // Since no more attempts left, not allowed to press Submit again but can press Next    // provided there are further pages ...    btnJudge.setEnabled(false);    if (rootIcon.currentPage < rootIcon.pageCount - 1){      btnNext.setEnabled(true);      finallyWrong = true;    };    break;  };  if (answerIsKnown && answers[i].correct == "false"){    // User has known wrong answer but does have tries left - give the hint special to this answer ...    comment = expression(templateData.problem[0].step[curPage].expression[i].feedback, engine);    hint = templateData.problem[0].step[curPage].expression[i].url;    break;  };  // Loop over the hints for this step ...  theHintToShow = undefined;  for (kk = 0; kk < nHints; kk++){    // Is the attempt equal to or greater than the number quited in the kk'th hint?     if (attempts >= templateData.problem[0].step[curPage].hint[kk].attemptsToHint){      // Greater than the current value (if there is one)? If so, overwrite it ...      if (theHintToShow == undefined || templateData.problem[0].step[curPage].hint[kk].attemptsToHint > theHintToShow){        theHintToShow = kk;      };    };  };  attemptsShowHint = templateData.problem[0].step[curPage].attemptsToHint;  if (theHintToShow == undefined){    // User has unknown wrong answer but hasn't used enough tries yet for  hint - do nothing ...    hint = "";    comment = expression(templateData.problem[0].step[curPage].intermediateComment, engine);   } else {    // Give hint ...    hint = templateData.problem[0].step[curPage].hint[theHintToShow].url;    comment = expression(templateData.problem[0].step[curPage].hint[theHintToShow], engine);   };};engine[answers[i].result] = answers[i].answer;// Loop again and add the summary lines from from any correct for (i = 0; i < answers.length; i++){ if (answers[i].correct == "true"){    summaryLine[curPage] = summaryLine[curPage] + expression(templateData.problem[0].step[curPage].expression[i].internalOnly, engine) + theReturn;  };};/*summaryLine[curPage] = curPage + ' ';for (i = 0; i < answers.length; i++){  // Loop over all possible answers and extract the comments s (for the summary) from those that have correct set to TRUE ...  if (answers[i].correct == "true"){    // Concatenate ...    summaryLine[curPage] = summaryLine[curPage] + ' ' + expression(templateData.problem[0].step[curPage].expression[i].internalOnly, engine);  };};//answerType = ""; //could be known correct, known incorrect or unkown (and incorrect)//loop over answers, checking for the user's inputfor (i = 0; i < answers.length; i++){  // Does the user's answer match one in the XML? (True or false)  // N.B. Not necessarily correct  if (answers[i].within == undefined || isNaN(entryText.text)){    answerIsCorrect = answers[i].answer == entryText.text;  } else {    pcError = 100 * ((answers[i].answer - entryText.text) / answers[i].answer);    answerIsCorrect = Math.abs(pcError) <= answers[i].within;  };  // Show no hint if the answer is correct if if still within attempts limit (otherwise show hint) ...  if (answerIsCorrect || attempts < attemptsShowHint){    hint = "";    comment = "";  } else {    hint = templateData.problem[0].step[curPage].hint[0].url;    comment = templateData.problem[0].step[curPage].hint[0];   };//  if (answers[i].answer == entryText.text && answers[i].correct == "true"){  if (answerIsCorrect && answers[i].correct == "true"){    // Known CORRECT answer ...    feedback = answers[i].feedback + " " + answers[i].units;    if (answers[i].answer != entryText.text) { feedback += ' (The exact answer is ' + answers[i].answer + " " + answers[i].units + '.)'; };    btnJudge.setEnabled(false);    if (rootIcon.currentPage < rootIcon.pageCount - 1){      btnNext.setEnabled(true);    };    break; // User's answer has been found among those known - look no further//  } else if (answers[i].answer == entryText.text && answers[i].correct == "false"){  } else if (answerIsCorrect && answers[i].correct == "false"){    // Known INCORRECT answer ...    feedback = answers[i].feedback;    if (attempts < maxAttempts){      // Another attempt is allowed ...      feedback += "<br><br>Try again.";      feedback += "<br><br>" + templateData.problem[0].step[curPage].hint;      feedback += "<br><br>You have " + (maxAttempts - attempts) + " attempts remaining.";    } else {      // No further attempts allowed ...      feedback += "<br><br>The correct answer" + (possibleAnswers.length > 1 ? "s " : " ") + (possibleAnswers.length > 1 ? "are " : "is ");      for (j = 0; j < possibleAnswers.length; j++){        feedback += possibleAnswers[j].answer + " " + possibleAnswers[j].units + " ";      };      // Disable the Submit button ...      btnJudge.setEnabled(false);      // Enable the Next button if there is a next page ...      if (rootIcon.currentPage < rootIcon.pageCount - 1){        btnNext.setEnabled(true);      };    };    break; // User's answer has been found among those known - look no further   } else {    // Unknown INCORRECT answer ...    feedback = "No, that's not right";    if (attempts < maxAttempts){      // Another attempt is allowed ...      feedback += "<br><br>Try again.";      feedback += "<br><br>You have " + (maxAttempts - attempts) + " attempts remaining.";    } else {      // No further attempts allowed ...      feedback += "<br><br>The correct answer" + (possibleAnswers.length > 1 ? "s " : " ") + (possibleAnswers.length > 1 ? "are " : "is ");      for (j = 0; j < possibleAnswers.length; j++){        feedback += possibleAnswers[j].answer + " " + possibleAnswers[j].units + " ";      };      btnJudge.setEnabled(false);      if (rootIcon.currentPage < rootIcon.pageCount - 1){        btnNext.setEnabled(true);      };    };  };};engine[possibleAnswers[0].result] = possibleAnswers[0].answer;//summaryLine[curPage] = curPage;debug('summaryLine[curPage] ' + summaryLine[curPage]);debug('templateData.problem[0].step[curPage].expression[i].internalOnly ' + templateData.problem[0].step[curPage].expression[i].internalOnly);summaryLine[curPage] = curPage + ' ' + expression(templateData.problem[0].step[curPage].expression[i].internalOnly, engine);*/]]></SCR>						<SCR name="Layout for Feedback"><![CDATA[// Set layout parameters according to which layout has been selected in the template ...if (stepLayout == 0){ // Single column ...  fbLayout = { x: problem._x, y: promptImage._y + promptImage._height + 20, width: 700}; // ... comment};if (stepLayout == 1){ // Double column ...  fbLayout = { x: 410, y: 70, width: 350}; // ... comment}; ]]></SCR>						<DIS h="10" id="fb" name="feedback" x="fbLayout.x" y="fbLayout.y" w="fbLayout.width" type="text"><![CDATA[{comment}]]></DIS>						<SCR name="Layout for Hint Image"><![CDATA[// Set layout parameters according to which layout has been selected in the template ...if (stepLayout == 0){ // Single column ...  hintImg = { x: problem._x, y: fbLayout.y + fb._height + 20 }; // ... hint image};if (stepLayout == 1){ // Double column ...  hintImg = { x: fbLayout.x, y: fbLayout.y + fb._height + 20 }; // ... hint image}; ]]></SCR>						<DIS id="hintImg" name="hintImg" x="hintImg.x" y="hintImg.y" type="ext" url="{hint}"><![CDATA[]]></DIS>						<INT name="fitToSize" perpetual="0">							<RES name="onLoad" type="event" eventName="onLoad" icon="hintImg" erase="1" exit="0">								<SCR name="resize"><![CDATA[maxWidthAvailable = 340;maxHeightAvailable = 600 - 165 - fb._height - 20;// By what factor does the image's width (or height) exceed the width (or height) available ...scaleWidth =  hintImg._width / maxWidthAvailable;scaleHeight = hintImg._height / maxHeightAvailable;// Which is the larger ...largerScale = Math.max (scaleHeight, scaleWidth); // Scale the picture down by largerScale PROVIDED it is necessary ...if (largerScale > 1) {  hintImg._width = hintImg._width / largerScale;    hintImg._height = hintImg._height / largerScale;  };/*// Axial ratio of image ...p = hintImage._width / hintImage._height;// Available height ...maxHeightAvailable = 600 - 165 - fb._height - 20;maxWidthAvailable = 340;// Reduce height if too big ...if (hintImage._height > availableHintImg._height){  hintImage._height = availableHintImg._height;};// Set width ...//hintImg._width = hintImg._height * p; */]]></SCR>							</RES>						</INT>					</RES>					<RES id="summary" swf="templatePath + 'flex/button.swf'" enabled="1" rs="btnSummary" name="Summary" type="button" x="btnSummaryLayout.x" y="btnSummaryLayout.y" label="Summary" erase="1" exit="0">						<SCR name="Construct Summary"><![CDATA[// Find the current state of the buttons ...abilityJudge = btnJudge.enabled;abilitySummary = btnSummary.enabled;abilityNext = btnNext.enabled;// Switch all buttons (other than Close) off until Close has been pressed ...btnJudge.setEnabled(false);btnSummary.setEnabled(false);btnNext.setEnabled(false);panel_x = 150; panel_y = 150;panel_w = 400; panel_h = 300;text = 'Correct answers from previous steps:' + String.fromCharCode(10) + String.fromCharCode(10);for (i = 0; i < curPage; i++){  text = text + summaryLine[i];};]]></SCR>						<DIS id="summaryPanel" w="panel_w" h="panel_h" x="panel_x" y="panel_y" type="ext" url="templatePath  + 'flex/whitePanel.swf'"><![CDATA[]]></DIS>						<DIS id="summaryText" name="Show the Summary" x="panel_x + 10" y="panel_y + 10" w="panel_w - 20" h="panel_h - 40" type="text"><![CDATA[{text}]]></DIS>						<INT name="Close Button" perpetual="1">							<RES id="closeButton" swf="templatePath + 'flex/button.swf'" enabled="1" rs="btnCloseSummary" name="return" type="button" x="panel_x + panel_w - 90" y="panel_y + panel_h - 30" label="Close" erase="1" exit="1">								<SCR name="Remove Summary"><![CDATA[// Switch all buttons (other than Close) off until Close has been pressed ...btnJudge.setEnabled(abilityJudge);btnSummary.setEnabled(abilitySummary);btnNext.setEnabled(abilityNext);// Remove all parts of the summary (panel, text, ...) ...summaryPanel.removeMovieClip();summaryText.removeMovieClip();btnCloseSummary.removeMovieClip();]]></SCR>							</RES>						</INT>					</RES>					<RES id="[Untitled]" swf="templatePath + 'flex/button.swf'" enabled="0" rs="btnNext" name="moveOn" type="button" x="btnNextLayout.x" y="btnNextLayout.y" label="Next Step" erase="1" exit="0">						<SCR name="nextPage"><![CDATA[//Forced to return if wrong at very last attempt but not exceeeded number of goes at this type oy questionmaxThisTypeOfQuestion = 3;if (thisTypeOfQuestion == undefined) { thisTypeOfQuestion = 0; };if (finallyWrong && thisTypeOfQuestion < maxThisTypeOfQuestion){  // If the user still doesn't have the answer check to see whether still in the limit of  // maxThisTypeOfQuestion. If so, force the user to go back. If the student isn't wrong  // or is wrong but has had the maximum number of tries, go tot he next problem ...  needNewVariables = true;  theCurrentPage = rootIcon.currentPage;  theDestination = theCurrentPage - forceBack;  // Check for meaningless values: the earliest possible page is 1 ...  if (theDestination < 1) { theDestination = 1; };  // thisTypeOfQuestion may be undefined at the very beginning; if so, set it to zero ...  thisTypeOfQuestion = thisTypeOfQuestion + 1;  // Make the jump ...  rootIcon.gotoPage(theDestination);} else {  // Re-set the counter and go to the next page ...  thisTypeOfQuestion = 0;  rootIcon.nextPage();};]]></SCR>					</RES>				</INT>			</PG>			<PG name="Closing Screen">				<SCR name="Read Final Comment from XML"><![CDATA[finalComment = templateData.problem[0].finalScreen[0];finalComment = expression(finalComment, engine);]]></SCR>				<DIS name="feedback" x="40" y="40" w="400" h="10" type="text"><![CDATA[{finalComment}]]></DIS>			</PG>		</IFC>		<BIN name="Deleted Items">			<SCR name="[Untitled]"><![CDATA[debug("Below panel rootIcon.getPageIndex() is " + rootIcon.getPageIndex()); ]]></SCR>			<SCR name="[Untitled]"><![CDATA[//icon.nextSibling.firstChild.duplicate(templateData.problem[0].step.length - 1);icon.parentNode.nextSibling.duplicate(templateData.problem[0].step.length - 1);]]></SCR>			<SCR name="[Untitled]"><![CDATA[debug("ENTRY rootIcon.getPageIndex() is " + rootIcon.getPageIndex()); ]]></SCR>			<SCR isFunc="1" name="testFunction"><![CDATA[qq = 2 * q;]]></SCR>			<SCR name="DEBUG 1"><![CDATA[debug("Script 1");]]></SCR>			<SCR name="DEBUG 2"><![CDATA[debug("Script 2");]]></SCR>			<SCR name="DEBUG 3"><![CDATA[debug("Script 3");]]></SCR>			<RES rs="entryText" name="entryText" type="textEntry" x="410" y="problem._y " w="260" h="100" phrase="match this" scrolling="0" border="1" erase="1" exit="0" />			<RES swf="templatePath + 'flex/button.swf'" rs="btnJudge" name="judge" type="button" x="680" y="40" label="Submit" erase="1" exit="0">				<SCR name="judge"><![CDATA[attempts++;attemptsLeft = maxAttempts - attempts;//  attemptsShowHint = templateData.problem[0].step[curPage].attemptsToHint;// templateData.problem[0].step[curPage].hint[0].url// Build up the summary array ...summaryLine[curPage] = (curPage + 1) + ' ';// First loop through all possible answers associating the variable with the value ...for (i = 0; i < possibleAnswers.length; i++){  engine[possibleAnswers[i].result] = possibleAnswers[i].answer;};// ... it may be that more than one value is associated with one variable (and one only). Will deal with// this by overwriting later ...// If a correct answer, build up summary ...//if (obj.correct == 'true'){//  thisSummaryLine = expression(templateData.problem[0].step[curPage].expression[i].internalOnly, engine);//  summaryLine[curPage] = summaryLine[curPage] + thisSummaryLine + theReturn;//debug('The summary text for ' + (curPage + 1) + ' is ' + thisSummaryLine); //};for (i = 0; i < answers.length; i++){  // Decide whether or not this is a known answer ...  // An exact answer or within a range?  // No range specified or answer is zero ...debug ("answers[i].within " + answers[i].within);  if (answers[i].answer == 0 || answers[i].within == undefined || answers[i].within == "" || isNaN(entryText.text)){    // EXACT ...    answerIsKnown = Number(answers[i].answer) == Number(entryText.text);  } else {    // RANGE ...    // Only work with a range if a percentage (for the range) has been set and the number is not zero ...    pcError = 100 * ((answers[i].answer - entryText.text) / answers[i].answer);    answerIsKnown = Math.abs(pcError) <= answers[i].within;  };  // Now test where in the logic the present combination lies ...  if (answerIsKnown && answers[i].correct == "true"){    // User has correct answer - note this and move to next step    comment = expression(templateData.problem[0].step[curPage].expression[i].feedback, engine);    // Since correct, not allowed to press Submit again but can press Next    // provided there are further pages ...    btnJudge.setEnabled(false);    if (rootIcon.currentPage < rootIcon.pageCount - 1){      btnNext.setEnabled(true);    };    thisSummaryLine = expression(templateData.problem[0].step[curPage].expression[i].internalOnly, engine);    summaryLine[curPage] = summaryLine[curPage] + thisSummaryLine + theReturn;    break;  };  if (attempts == maxAttempts){    // User has run out of steps and answer is wrong    // Had answer been correct, above would have been satisfied and break would have taken effect    comment = expression(templateData.problem[0].step[curPage].finalComment, engine);     hint = templateData.problem[0].step[curPage].expression[i].url;    // Since no more attempts left, not allowed to press Submit again but can press Next    // provided there are further pages ...    btnJudge.setEnabled(false);    if (rootIcon.currentPage < rootIcon.pageCount - 1){      btnNext.setEnabled(true);    };    break;  };  if (answerIsKnown && answers[i].correct == "false"){    // User has known wrong answer but does have tries left - give the hint special to this answer ...    comment = expression(templateData.problem[0].step[curPage].expression[i].feedback, engine);    hint = templateData.problem[0].step[curPage].expression[i].url;    break;  };  // Loop over the hints for this step ...  theHintToShow = undefined;  for (kk = 0; kk < nHints; kk++){    // Is the attempt equal to or greater than the number quited in the kk'th hint?     if (attempts >= templateData.problem[0].step[curPage].hint[kk].attemptsToHint){      // Greater than the current value (if there is one)? If so, overwrite it ...      if (theHintToShow == undefined || templateData.problem[0].step[curPage].hint[kk].attemptsToHint > theHintToShow){        theHintToShow = kk;      };    };  };  attemptsShowHint = templateData.problem[0].step[curPage].attemptsToHint;  if (theHintToShow == undefined){    // User has unknown wrong answer but hasn't used enough tries yet for general hint - do nothing ...    hint = "";    comment = expression(templateData.problem[0].step[curPage].intermediateComment, engine);   } else {    // Give general hint ...    hint = templateData.problem[0].step[curPage].hint[theHintToShow].url;    comment = expression(templateData.problem[0].step[curPage].hint[theHintToShow], engine);   };};engine[answers[i].result] = answers[i].answer;// Loop again and add the summary lines from from any correct for (i = 0; i < answers.length; i++){ if (answers[i].correct == "true"){    summaryLine[curPage] = summaryLine[curPage] + expression(templateData.problem[0].step[curPage].expression[i].internalOnly, engine) + theReturn;  };};/*summaryLine[curPage] = curPage + ' ';for (i = 0; i < answers.length; i++){  // Loop over all possible answers and extract the comments s (for the summary) from those that have correct set to TRUE ...  if (answers[i].correct == "true"){    // Concatenate ...    summaryLine[curPage] = summaryLine[curPage] + ' ' + expression(templateData.problem[0].step[curPage].expression[i].internalOnly, engine);  };};//answerType = ""; //could be known correct, known incorrect or unkown (and incorrect)//loop over answers, checking for the user's inputfor (i = 0; i < answers.length; i++){  // Does the user's answer match one in the XML? (True or false)  // N.B. Not necessarily correct  if (answers[i].within == undefined || isNaN(entryText.text)){    answerIsCorrect = answers[i].answer == entryText.text;  } else {    pcError = 100 * ((answers[i].answer - entryText.text) / answers[i].answer);    answerIsCorrect = Math.abs(pcError) <= answers[i].within;  };  // Show no hint if the answer is correct if if still within attempts limit (otherwise show hint) ...  if (answerIsCorrect || attempts < attemptsShowHint){    hint = "";    comment = "";  } else {    hint = templateData.problem[0].step[curPage].hint[0].url;    comment = templateData.problem[0].step[curPage].hint[0];   };//  if (answers[i].answer == entryText.text && answers[i].correct == "true"){  if (answerIsCorrect && answers[i].correct == "true"){    // Known CORRECT answer ...    feedback = answers[i].feedback + " " + answers[i].units;    if (answers[i].answer != entryText.text) { feedback += ' (The exact answer is ' + answers[i].answer + " " + answers[i].units + '.)'; };    btnJudge.setEnabled(false);    if (rootIcon.currentPage < rootIcon.pageCount - 1){      btnNext.setEnabled(true);    };    break; // User's answer has been found among those known - look no further//  } else if (answers[i].answer == entryText.text && answers[i].correct == "false"){  } else if (answerIsCorrect && answers[i].correct == "false"){    // Known INCORRECT answer ...    feedback = answers[i].feedback;    if (attempts < maxAttempts){      // Another attempt is allowed ...      feedback += "<br><br>Try again.";      feedback += "<br><br>" + templateData.problem[0].step[curPage].hint;      feedback += "<br><br>You have " + (maxAttempts - attempts) + " attempts remaining.";    } else {      // No further attempts allowed ...      feedback += "<br><br>The correct answer" + (possibleAnswers.length > 1 ? "s " : " ") + (possibleAnswers.length > 1 ? "are " : "is ");      for (j = 0; j < possibleAnswers.length; j++){        feedback += possibleAnswers[j].answer + " " + possibleAnswers[j].units + " ";      };      // Disable the Submit button ...      btnJudge.setEnabled(false);      // Enable the Next button if there is a next page ...      if (rootIcon.currentPage < rootIcon.pageCount - 1){        btnNext.setEnabled(true);      };    };    break; // User's answer has been found among those known - look no further   } else {    // Unknown INCORRECT answer ...    feedback = "No, that's not right";    if (attempts < maxAttempts){      // Another attempt is allowed ...      feedback += "<br><br>Try again.";      feedback += "<br><br>You have " + (maxAttempts - attempts) + " attempts remaining.";    } else {      // No further attempts allowed ...      feedback += "<br><br>The correct answer" + (possibleAnswers.length > 1 ? "s " : " ") + (possibleAnswers.length > 1 ? "are " : "is ");      for (j = 0; j < possibleAnswers.length; j++){        feedback += possibleAnswers[j].answer + " " + possibleAnswers[j].units + " ";      };      btnJudge.setEnabled(false);      if (rootIcon.currentPage < rootIcon.pageCount - 1){        btnNext.setEnabled(true);      };    };  };};engine[possibleAnswers[0].result] = possibleAnswers[0].answer;//summaryLine[curPage] = curPage;debug('summaryLine[curPage] ' + summaryLine[curPage]);debug('templateData.problem[0].step[curPage].expression[i].internalOnly ' + templateData.problem[0].step[curPage].expression[i].internalOnly);summaryLine[curPage] = curPage + ' ' + expression(templateData.problem[0].step[curPage].expression[i].internalOnly, engine);*/]]></SCR>				<DIS id="fb" name="feedback" x="410" y="70" w="350" h="10" type="text"><![CDATA[{comment}]]></DIS>				<DIS id="hintImg" name="hintImg" x="fb._x" y="fb._y + fb._height + 20" type="ext" url="{hint}"><![CDATA[]]></DIS>				<INT name="fitToSize" perpetual="0">					<RES name="onLoad" type="event" eventName="onLoad" icon="hintImg" erase="1" exit="0">						<SCR name="resize"><![CDATA[maxWidthAvailable = 340;maxHeightAvailable = 600 - 165 - fb._height - 20;// By what factor does the image's width (or height) exceed the width (or height) available ...scaleWidth =  hintImg._width / maxWidthAvailable;scaleHeight = hintImg._height / maxHeightAvailable;// Which is the larger ...largerScale = Math.max (scaleHeight, scaleWidth); // Scale the picture down by largerScale PROVIDED it is necessary ...if (largerScale > 1) {  hintImg._width = hintImg._width / largerScale;    hintImg._height = hintImg._height / largerScale;  };/*// Axial ratio of image ...p = hintImage._width / hintImage._height;debug ("Axial ratio: " + p);// Available height ...maxHeightAvailable = 600 - 165 - fb._height - 20;maxWidthAvailable = 340;debug ("Available: " + maxHeightAvailable);// Reduce height if too big ...if (hintImage._height > availableHintImg._height){  hintImage._height = availableHintImg._height;};// Set width ...//hintImg._width = hintImg._height * p; */]]></SCR>					</RES>				</INT>			</RES>			<RES id="summary" swf="templatePath + 'flex/button.swf'" enabled="1" rs="btnSummary" name="Summary" type="button" x="680" y="510" label="Summary" erase="1" exit="0">				<SCR name="Display Summary"><![CDATA[panel_x = 150; panel_y = 150;panel_w = 400; panel_h = 300;//text = 'Correct answers from previous steps:' + the Result + the Result;text = 'Correct answers from previous steps:' + String.fromCharCode(10) + String.fromCharCode(10);for (i = 0; i < curPage; i++){  text = text + summaryLine[i];};]]></SCR>				<DIS id="summaryPanel" w="panel_w" h="panel_h" x="panel_x" y="panel_y" type="ext" url="templatePath  + 'flex/whitePanel.swf'"><![CDATA[]]></DIS>				<DIS name="[Untitled]" x="panel_x + 10" y="panel_y + 10" w="panel_w - 20" h="panel_h - 40" type="text"><![CDATA[{text}]]></DIS>				<INT name="[Untitled]" perpetual="0">					<RES id="return" swf="templatePath + 'flex/button.swf'" enabled="1" rs="btnNext" name="return" type="button" x="panel_x + panel_w - 90" y="panel_y + panel_h - 30" label="Close" erase="1" exit="1">						<SCR name="nextPage"><![CDATA[// Remove all parts of the summary (panel, text, ...) ...summary.removeMovieClip();]]></SCR>					</RES>				</INT>			</RES>			<PG name="opening">				<SCR name="Read Opening Comment from XML"><![CDATA[openingComment = templateData.problem[0].firstScreen;debug ('templateData.problem[0] is ' + templateData.problem[0]); debug ('openingComment is ' + openingComment); openingComment = expression(openingComment, engine);debug ('openingComment is ' + openingComment); ]]></SCR>				<DIS name="feedback" x="40" y="40" w="400" h="10" type="text"><![CDATA[{openingComment}]]></DIS>				<INT name="basicInteraction" perpetual="1">					<RES id="moveOn" swf="templatePath + 'flex/button.swf'" enabled="0" rs="btnNext" name="moveOn" type="button" x="680" y="540" label="Continue" erase="1" exit="0">						<SCR name="nextPage"><![CDATA[rootIcon.nextPage();]]></SCR>					</RES>				</INT>			</PG>			<DEC path="stepLayout" name="Decide Layout" repeat="1" branch="calculate" pause="0" erase="0" eraseOnExit="0">				<PG name="One Column">					<DIS id="problem" name="problem" x="40" y="40" w="350" h="10" type="text"><![CDATA[{expression(templateData.problem[0].step[curPage].prompt, engine)}]]></DIS>				</PG>				<PG name="Two Column" />			</DEC>		</BIN>	</LO>